// hooks/useSalesApi.tsimport { useState, useCallback } from 'react';import { salesApi, SaleFilters } from '@/app/lib/api/sales';import { Sale, Product, SaleItem, PaymentSplit, Installment } from '@/app/lib/types/types';interface BackendSaleItem extends Omit<SaleItem, 'rubro' | 'unit'> {  unit: string;  rubro?: string;}interface BackendPayment {  method: string;  amount: number;}interface BackendSale extends Omit<Sale, 'id' | 'products' | 'paymentMethods'> {  id: string | number;  items?: BackendSaleItem[];  payments?: BackendPayment[];  installments?: Installment[];}export const useSalesApi = () => {  const [sales, setSales] = useState<Sale[]>([]);  const [loading, setLoading] = useState(false);  const [error, setError] = useState<string | null>(null);  const fetchSales = useCallback(async (filters?: SaleFilters) => {    setLoading(true);    setError(null);    try {      const data = await salesApi.getAll(filters) as unknown as BackendSale[];      const formattedSales = data.map((sale: BackendSale) => ({        ...sale,        id: Number(sale.id),        date: sale.date,        products: sale.items?.map((item: BackendSaleItem) => ({          id: item.productId,          name: item.productName,          quantity: item.quantity,          unit: item.unit as Product['unit'],          price: item.price,          size: item.size,          color: item.color,          discount: item.discount || 0,          surcharge: item.surcharge || 0,          basePrice: item.basePrice,          notes: item.notes,          description: item.description,          rubro: item.rubro || 'General',          fromBudget: item.fromBudget,          budgetId: item.budgetId,          costPrice: item.costPrice || 0,          profit: item.profit,          profitPercentage: item.profitPercentage,          stock: 0,          currentPrice: item.price,        })) || [],        paymentMethods: sale.payments?.map((p: BackendPayment) => ({          method: p.method as PaymentSplit['method'],           amount: p.amount,        })) || [],      })) as Sale[];      setSales(formattedSales);      return formattedSales;    } catch (err: unknown) {      const errorMessage = err instanceof Error ? err.message : 'Error al cargar ventas';      setError(errorMessage);      console.error('Error fetching sales:', err);      throw err;    } finally {      setLoading(false);    }  }, []);  const addSale = useCallback(async (sale: Omit<Sale, 'id'> & { installments?: Installment[] }) => {    setLoading(true);    setError(null);    try {      const saleData = {        ...sale,        items: sale.products?.map((product: Product) => ({          productId: product.id,          productName: product.name,          quantity: product.quantity,          unit: product.unit,          price: product.price,          size: product.size,          color: product.color,          discount: product.discount || 0,          surcharge: product.surcharge || 0,          basePrice: product.basePrice,          notes: product.notes,          description: product.description,          rubro: product.rubro,          fromBudget: product.fromBudget,          budgetId: product.budgetId,          costPrice: product.costPrice,          profit: product.profit,          profitPercentage: product.profitPercentage,        })) || [],        payments: sale.paymentMethods?.map((pm: PaymentSplit) => ({          amount: pm.amount,          method: pm.method,          date: sale.date,        })) || [],        installments: sale.installments || undefined,      };      const newSale = await salesApi.create(saleData as unknown as Omit<Sale, 'id'>) as unknown as BackendSale;      const formattedSale = {        ...newSale,        id: Number(newSale.id),        products: newSale.items?.map((item: BackendSaleItem) => ({          id: item.productId,          name: item.productName,          quantity: item.quantity,          unit: item.unit as Product['unit'],          price: item.price,          size: item.size,          color: item.color,          discount: item.discount || 0,          surcharge: item.surcharge || 0,          basePrice: item.basePrice,          notes: item.notes,          description: item.description,          rubro: item.rubro || 'General',          fromBudget: item.fromBudget,          budgetId: item.budgetId,          costPrice: item.costPrice || 0,          profit: item.profit,          profitPercentage: item.profitPercentage,          stock: 0,          currentPrice: item.price,        })) || [],        paymentMethods: newSale.payments?.map((p: BackendPayment) => ({          method: p.method as PaymentSplit['method'],          amount: p.amount,        })) || [],      } as Sale;      setSales((prev) => [...prev, formattedSale]);      return formattedSale;    } catch (err: unknown) {      const errorMessage = err instanceof Error ? err.message : 'Error al crear venta';      setError(errorMessage);      throw err;    } finally {      setLoading(false);    }  }, []);  const updateSale = useCallback(    async (id: number, updates: Partial<Sale>) => {      setLoading(true);      setError(null);      try {        interface BackendUpdatePayload extends Omit<Partial<Sale>, 'products' | 'paymentMethods'> {          items?: BackendSaleItem[];          payments?: BackendPayment[];        }        const { products, paymentMethods, ...rest } = updates;        const updateData: BackendUpdatePayload = { ...rest };        if (products) {          updateData.items = products.map((product: Product) => ({            productId: product.id,            productName: product.name,            quantity: product.quantity,            unit: product.unit,            price: product.price,            size: product.size,            color: product.color,            discount: product.discount || 0,            surcharge: product.surcharge || 0,            basePrice: product.basePrice,            notes: product.notes,            description: product.description,            rubro: product.rubro,            fromBudget: product.fromBudget,            budgetId: product.budgetId,            costPrice: product.costPrice,            profit: product.profit,            profitPercentage: product.profitPercentage,          }));        }        if (paymentMethods) {          updateData.payments = paymentMethods.map((pm: PaymentSplit) => ({            amount: pm.amount,            method: pm.method,            date: updates.date || new Date().toISOString(),          }));        }        const updated = await salesApi.update(id, updateData as Partial<Sale>) as unknown as BackendSale;        const formattedSale = {          ...updated,          id: Number(updated.id),          products: updated.items?.map((item: BackendSaleItem) => ({            id: item.productId,            name: item.productName,            quantity: item.quantity,            unit: item.unit as Product['unit'],            price: item.price,            size: item.size,            color: item.color,            discount: item.discount || 0,            surcharge: item.surcharge || 0,            basePrice: item.basePrice,            notes: item.notes,            description: item.description,            rubro: item.rubro || 'General',            fromBudget: item.fromBudget,            budgetId: item.budgetId,            costPrice: item.costPrice || 0,            profit: item.profit,            profitPercentage: item.profitPercentage,            stock: 0,            currentPrice: item.price,          })) || [],          paymentMethods: updated.payments?.map((p: BackendPayment) => ({            method: p.method as PaymentSplit['method'],            amount: p.amount,          })) || [],        } as Sale;        setSales((prev) =>          prev.map((s) => (s.id === id ? formattedSale : s))        );        return formattedSale;      } catch (err: unknown) {        const errorMessage = err instanceof Error ? err.message : 'Error al actualizar venta';        setError(errorMessage);        throw err;      } finally {        setLoading(false);      }    },    []  );  const deleteSale = useCallback(async (id: number) => {    setLoading(true);    setError(null);    try {      await salesApi.delete(id);      setSales((prev) => prev.filter((s) => s.id !== id));    } catch (err: unknown) {      const errorMessage = err instanceof Error ? err.message : 'Error al eliminar venta';      setError(errorMessage);      throw err;    } finally {      setLoading(false);    }  }, []);  return {    sales,    loading,    error,    fetchSales,    addSale,    updateSale,    deleteSale,    setSales,  };};