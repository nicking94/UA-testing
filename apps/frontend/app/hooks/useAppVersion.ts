"use client";import { useState, useEffect, useCallback, useRef } from "react";import { APP_VERSION } from "@/app/lib/constants/constants";import { userPreferencesApi } from "@/app/lib/api/user-preferences";import { authApi } from "@/app/lib/api/auth";export const useAppVersion = () => {  const [setShowUpdateModal] = useState(false);  const [isUpdating, setIsUpdating] = useState(false);  const [currentStoredVersion, setCurrentStoredVersion] = useState<    string | undefined  >();  const [minLoadTimePassed, setMinLoadTimePassed] = useState(false);  const [isAutoUpdate, setIsAutoUpdate] = useState(false);  const minLoadTimePassedRef = useRef(false);  const fetchPreferences = useCallback(async () => {    try {      const prefs = await userPreferencesApi.get();      return prefs;    } catch (error) {      console.error("Error fetching preferences:", error);      return null;    }  }, []);  const updateStoredVersion = useCallback(async () => {    try {      const existingPrefs = await fetchPreferences();      if (existingPrefs && existingPrefs.id) {        await userPreferencesApi.update(existingPrefs.id, {          appVersion: APP_VERSION,        });      } else {        await userPreferencesApi.create({          acceptedTerms: false,          itemsPerPage: 10,          appVersion: APP_VERSION,        });      }    } catch (error) {      console.error("❌ Error guardando versión:", error);      throw error;    }  }, [fetchPreferences]);  const autoUpdate = useCallback(async () => {    setIsUpdating(true);    setIsAutoUpdate(true);     setMinLoadTimePassed(false);    minLoadTimePassedRef.current = false;    let minLoadTimer: NodeJS.Timeout | undefined = undefined;    try {      minLoadTimer = setTimeout(() => {        setMinLoadTimePassed(true);        minLoadTimePassedRef.current = true;      }, 2000);      await updateStoredVersion();      await new Promise<void>((resolve) => {        const checkInterval = setInterval(() => {          if (minLoadTimePassedRef.current) {            clearInterval(checkInterval);            resolve();          }        }, 100);      });      if (minLoadTimer) clearTimeout(minLoadTimer);      setTimeout(() => {        window.location.reload();      }, 300);    } catch (error) {      console.error("❌ Error durante la actualización automática:", error);      if (minLoadTimer) clearTimeout(minLoadTimer);      setIsUpdating(false);      setIsAutoUpdate(false);      setMinLoadTimePassed(false);      minLoadTimePassedRef.current = false;    }  }, [updateStoredVersion]);  const checkForUpdates = useCallback(async () => {    try {      const preferences = await fetchPreferences();      const storedVersion = preferences?.appVersion;      setCurrentStoredVersion(storedVersion);      if (!storedVersion) {        await updateStoredVersion();        return false;      }      if (storedVersion !== APP_VERSION) {        await autoUpdate();        return true;      }      return false;    } catch (error) {      console.error("❌ Error checking app version:", error);      return false;    }  }, [updateStoredVersion, autoUpdate, fetchPreferences]);  const forceUpdate = useCallback(async () => {    await autoUpdate();  }, [autoUpdate]);  const logoutAndUpdate = useCallback(async () => {    setIsUpdating(true);    setMinLoadTimePassed(false);    minLoadTimePassedRef.current = false;    let minLoadTimer: NodeJS.Timeout | undefined = undefined;    try {      minLoadTimer = setTimeout(() => {        setMinLoadTimePassed(true);        minLoadTimePassedRef.current = true;      }, 2000);      authApi.logout();      try {        await updateStoredVersion();      } catch (e) {        console.warn("Could not update version before logout", e);      }      await new Promise<void>((resolve) => {        const checkInterval = setInterval(() => {          if (minLoadTimePassedRef.current) {            clearInterval(checkInterval);            resolve();          }        }, 100);      });      if (minLoadTimer) clearTimeout(minLoadTimer);      setTimeout(() => {        window.location.href = "/login";      }, 300);    } catch (error) {      console.error("❌ Error durante logout y update:", error);      if (minLoadTimer) clearTimeout(minLoadTimer);      setIsUpdating(false);      setMinLoadTimePassed(false);      minLoadTimePassedRef.current = false;    }  }, [updateStoredVersion]);  useEffect(() => {    const initializeVersion = async () => {      await checkForUpdates();    };    const timer = setTimeout(() => {      initializeVersion();    }, 1000);    const interval = setInterval(checkForUpdates, 5 * 60 * 1000);    return () => {      clearTimeout(timer);      clearInterval(interval);    };  }, [checkForUpdates]);  return {    showUpdateModal: false,     setShowUpdateModal,    isUpdating,    minLoadTimePassed,    forceUpdate,    logoutAndUpdate,    currentVersion: APP_VERSION,    storedVersion: currentStoredVersion,    checkForUpdates,    isAutoUpdate,   };};