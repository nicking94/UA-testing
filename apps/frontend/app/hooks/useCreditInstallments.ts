"use client";import { useState, useCallback } from "react";import {  Installment,  CreditSale,  PaymentMethod,  DailyCashMovement,  InstallmentStatus,  Sale,  Product} from "@/app/lib/types/types";import { differenceInDays, isBefore } from "date-fns";import { getLocalDateString } from "../lib/utils/getLocalDate";import { calculatePrice } from "../lib/utils/calculations";import { salesApi } from "../lib/api/sales";import { installmentsApi } from "../lib/api/installments";import { dailyCashApi } from "../lib/api/daily-cash";import { customersApi } from "../lib/api/customers";export const useCreditInstallments = () => {  const [installments, setInstallments] = useState<Installment[]>([]);  const [loading, setLoading] = useState(false);  const [overdueInstallments, setOverdueInstallments] = useState<Installment[]>(    []  );  const calculateInstallments = (    totalAmount: number,    numberOfInstallments: number,    interestRate: number,    startDate: string  ): Installment[] => {    const installments: Installment[] = [];    const monthlyInterest = interestRate / 100;    const start = new Date(startDate);    for (let i = 1; i <= numberOfInstallments; i++) {      const dueDate = new Date(start);      dueDate.setMonth(dueDate.getMonth() + i);      const interestAmount =        interestRate > 0          ? (totalAmount / numberOfInstallments) * monthlyInterest          : 0;      const installmentAmount =        totalAmount / numberOfInstallments + interestAmount;      const installment: Installment = {        creditSaleId: 0,        number: i,        dueDate: dueDate.toISOString().split("T")[0],        amount: parseFloat(installmentAmount.toFixed(2)),        interestAmount: parseFloat(interestAmount.toFixed(2)),        penaltyAmount: 0,        status: "pendiente",        daysOverdue: 0,        createdAt: new Date().toISOString(),        updatedAt: new Date().toISOString(),      };      installments.push(installment);    }    return installments;  };  const getCreditSalesInInstallments = useCallback(async () => {    try {      const allSales = await salesApi.getAll({ credit: true });      const creditSales = allSales.filter(        (sale: Sale) =>          sale.creditType === "credito_cuotas" &&          sale.customerName      );      return creditSales as CreditSale[];    } catch (error) {      console.error("Error fetching credit sales in installments:", error);      return [];    }  }, []);  const checkOverdueInstallments = useCallback(async () => {    try {      const today = new Date();      const creditSales = await getCreditSalesInInstallments();      const creditSaleIds = creditSales.map((sale: CreditSale) => sale.id);      if (creditSaleIds.length === 0) {        setOverdueInstallments([]);        return [];      }      const allPending: Installment[] = [];      for (const saleId of creditSaleIds) {        const saleInstallments = await installmentsApi.getAll({           creditSaleId: saleId,          status: "pendiente"         });        allPending.push(...saleInstallments);      }      const overdue = allPending.filter((installment: Installment) => {        const dueDate = new Date(installment.dueDate);        return isBefore(dueDate, today);      });      for (const installment of overdue) {        const daysOverdue = differenceInDays(          today,          new Date(installment.dueDate)        );        const penaltyRate = 0.05;        const penaltyAmount = installment.amount * penaltyRate * daysOverdue;        await installmentsApi.update(installment.id!, {          status: "vencida" as InstallmentStatus,          penaltyAmount,          daysOverdue,          updatedAt: new Date().toISOString(),        });      }      const updatedOverdue: Installment[] = [];      for (const saleId of creditSaleIds) {        const saleOverdue = await installmentsApi.getAll({          creditSaleId: saleId,          status: "vencida"        });        updatedOverdue.push(...saleOverdue);      }      setOverdueInstallments(updatedOverdue);      return updatedOverdue;    } catch (error) {      console.error("Error checking overdue installments:", error);      return [];    }  }, [getCreditSalesInInstallments]);  const fetchInstallments = useCallback(    async (creditSaleId?: number) => {      setLoading(true);      try {        let installmentsData: Installment[];        if (creditSaleId) {          const sale = await salesApi.getById(creditSaleId);          if (sale && sale.creditType === "credito_cuotas") {            installmentsData = await installmentsApi.getAll({ creditSaleId });          } else {            installmentsData = [];          }        } else {          const creditSales = await getCreditSalesInInstallments();          const creditSaleIds = creditSales.map((sale: CreditSale) => sale.id);          if (creditSaleIds.length > 0) {            installmentsData = [];            for (const id of creditSaleIds) {              const saleInsts = await installmentsApi.getAll({ creditSaleId: id });              installmentsData.push(...saleInsts);            }          } else {            installmentsData = [];          }        }        setInstallments(installmentsData);        return installmentsData;      } catch (error) {        console.error("Error fetching installments:", error);        throw error;      } finally {        setLoading(false);      }    },    [getCreditSalesInInstallments]  );  const payInstallment = async (    installmentId: number,    paymentMethod: PaymentMethod  ): Promise<{ success: boolean; updatedInstallment?: Installment }> => {    try {      const today = getLocalDateString();      const installment = await installmentsApi.getById(installmentId);      if (!installment) throw new Error("Cuota no encontrada");      if (installment.creditSaleId === undefined) throw new Error("ID de venta a crédito no encontrado en la cuota");      const sale = await salesApi.getById(installment.creditSaleId!);      if (!sale) throw new Error("Venta no encontrada");      if (installment.status === "pagada") {        throw new Error("Esta cuota ya fue pagada");      }      let totalProfitFromProducts = 0;      if (sale.products && sale.products.length > 0) {        const totalSaleAmount = sale.total;        const installmentRatio = installment.amount / totalSaleAmount;        const saleTotalProfit = sale.products.reduce((sum: number, product: Product) => {          const priceInfo = calculatePrice(            product,            product.quantity,            product.unit          );          return sum + priceInfo.profit;        }, 0);        totalProfitFromProducts = saleTotalProfit * installmentRatio;      }      const now = new Date().toISOString();      const movement: DailyCashMovement = {        id: Date.now(),        amount: installment.amount,        description: `Pago cuota #${installment.number} - ${sale.customerName}`,        type: "INGRESO",        date: now,        paymentMethod,        isCreditPayment: true,        originalSaleId: sale.id,        customerName: sale.customerName,        customerId: sale.customerId,        profit: totalProfitFromProducts + (installment.interestAmount || 0),        createdAt: now,        items:          sale.products?.map((product: Product) => ({            productId: product.id,            productName: product.name,            quantity: product.quantity,            unit: product.unit,            price: product.price,            costPrice: product.costPrice,            profit: calculatePrice(product, product.quantity, product.unit)              .profit,          })) || [],      };      let dailyCash = await dailyCashApi.getByDate(today);      if (!dailyCash) {        dailyCash = await dailyCashApi.create({          date: today,          movements: [movement],          closed: false,          totalIncome: installment.amount,          totalExpense: 0,          totalProfit: totalProfitFromProducts + (installment.interestAmount || 0),        });      } else {        const updatedMovements = [...dailyCash.movements, movement];        const totalIncome = updatedMovements          .filter((m: DailyCashMovement) => m.type === "INGRESO")          .reduce((sum: number, m: DailyCashMovement) => sum + m.amount, 0);        const totalProfit = updatedMovements          .filter((m: DailyCashMovement) => m.type === "INGRESO")          .reduce((sum: number, m: DailyCashMovement) => sum + (m.profit || 0), 0);        await dailyCashApi.update(dailyCash.id!, {          movements: updatedMovements,          totalIncome,          totalProfit,        });      }      const updatedInstallment = await installmentsApi.markAsPaid(installmentId, {        paymentDate: now,        paymentMethod,      });      setInstallments((prev) =>        prev.map((inst: Installment) =>          inst.id === installmentId ? updatedInstallment : inst        )      );      if (installment.status === "vencida") {        setOverdueInstallments((prev) =>          prev.filter((inst: Installment) => inst.id !== installmentId)        );      }      if (sale.customerId) {        const customer = await customersApi.getById(sale.customerId);        if (customer) {          const allSales = await salesApi.getAll();          const allCustomerCredits = allSales.filter(            (s: Sale) => s.customerId === sale.customerId && s.credit === true          );          let totalPending = 0;          for (const creditSale of allCustomerCredits) {            const saleInstallments = await installmentsApi.getAll({               creditSaleId: creditSale.id             });            const pendingAmount = saleInstallments              .filter(                (inst: Installment) =>                  inst.status === "pendiente" || inst.status === "vencida"              )              .reduce((sum: number, inst: Installment) => sum + inst.amount, 0);            totalPending += pendingAmount;          }          await customersApi.update(sale.customerId, {            pendingBalance: totalPending,            updatedAt: now,          });        }      }      return { success: true, updatedInstallment };    } catch (error) {      console.error("Error al pagar la cuota:", error);      throw error;    }  };  const payAllInstallments = async (    creditSaleId: number,    paymentMethod: PaymentMethod  ): Promise<{ success: boolean; updatedInstallments: Installment[] }> => {    try {      const today = getLocalDateString();      const sale = await salesApi.getById(creditSaleId);      if (!sale) throw new Error("Venta a crédito no encontrada");      const pendingInstallments = await installmentsApi.getAll({        creditSaleId,        status: "pendiente"      });      const overdueInstallmentsApi = await installmentsApi.getAll({        creditSaleId,        status: "vencida"      });      const allPending = [...pendingInstallments, ...overdueInstallmentsApi];      if (allPending.length === 0) {        throw new Error("No hay cuotas pendientes para pagar");      }      const totalAmount = allPending.reduce(        (sum: number, inst: Installment) => sum + inst.amount,        0      );      let totalProfitFromProducts = 0;      if (sale.products && sale.products.length > 0) {        const saleTotalProfit = sale.products.reduce((sum: number, product: Product) => {          const priceInfo = calculatePrice(            product,            product.quantity,            product.unit          );          return sum + priceInfo.profit;        }, 0);        const totalSaleAmount = sale.total;        const paymentRatio = totalAmount / totalSaleAmount;        totalProfitFromProducts = saleTotalProfit * paymentRatio;      }      const totalInterest = allPending.reduce(        (sum: number, inst: Installment) => sum + (inst.interestAmount || 0),        0      );      const now = new Date().toISOString();      const updatedInstallments: Installment[] = [];      for (const installment of allPending) {        const updated = await installmentsApi.markAsPaid(installment.id!, {          paymentDate: now,          paymentMethod,        });        updatedInstallments.push(updated);      }      const movement: DailyCashMovement = {        id: Date.now(),        amount: totalAmount,        description: `Pago total de ${allPending.length} cuotas - ${sale.customerName}`,        type: "INGRESO",        date: now,        paymentMethod,        isCreditPayment: true,        originalSaleId: sale.id,        customerName: sale.customerName,        customerId: sale.customerId,        profit: totalProfitFromProducts + totalInterest,        createdAt: now,        items:          sale.products?.map((product: Product) => ({            productId: product.id,            productName: product.name,            quantity: product.quantity,            unit: product.unit,            price: product.price,            costPrice: product.costPrice,            profit: calculatePrice(product, product.quantity, product.unit)              .profit,          })) || [],      };      let dailyCash = await dailyCashApi.getByDate(today);      if (!dailyCash) {        dailyCash = await dailyCashApi.create({          date: today,          movements: [movement],          closed: false,          totalIncome: totalAmount,          totalExpense: 0,          totalProfit: totalProfitFromProducts + totalInterest,        });      } else {        const updatedMovements = [...dailyCash.movements, movement];        const totalIncome = updatedMovements          .filter((m: DailyCashMovement) => m.type === "INGRESO")          .reduce((sum: number, m: DailyCashMovement) => sum + m.amount, 0);        const totalProfit = updatedMovements          .filter((m: DailyCashMovement) => m.type === "INGRESO")          .reduce((sum: number, m: DailyCashMovement) => sum + (m.profit || 0), 0);        await dailyCashApi.update(dailyCash.id!, {          movements: updatedMovements,          totalIncome,          totalProfit,        });      }      setInstallments((prev) =>        prev.map((inst: Installment) => {          const updated = updatedInstallments.find((u: Installment) => u.id === inst.id);          return updated ? updated : inst;        })      );      setOverdueInstallments((prev) =>        prev.filter(          (inst: Installment) => !updatedInstallments.some((u: Installment) => u.id === inst.id)        )      );      if (sale.customerId) {        const customer = await customersApi.getById(sale.customerId);        if (customer) {          const allSales = await salesApi.getAll();          const allCustomerCredits = allSales.filter(            (s: Sale) => s.customerId === sale.customerId && s.credit === true          );          let totalPending = 0;          for (const creditSale of allCustomerCredits) {            const saleInstallments = await installmentsApi.getAll({              creditSaleId: creditSale.id            });            const pendingAmount = saleInstallments              .filter(                (inst: Installment) =>                  inst.status === "pendiente" || inst.status === "vencida"              )              .reduce((sum: number, inst: Installment) => sum + inst.amount, 0);            totalPending += pendingAmount;          }          await customersApi.update(sale.customerId, {            pendingBalance: totalPending,            updatedAt: now,          });        }      }      return { success: true, updatedInstallments };    } catch (error) {      console.error("Error al pagar todas las cuotas:", error);      throw error;    }  };  const deleteCreditSale = async (    creditSaleId: number  ): Promise<{ success: boolean; message: string }> => {    try {      const sale = await salesApi.getById(creditSaleId);      if (!sale) {        throw new Error("Venta a crédito no encontrada");      }      const pendingInstallments = await installmentsApi.getAll({        creditSaleId,        status: "pendiente"      });      const overdueInstallmentsApi = await installmentsApi.getAll({        creditSaleId,        status: "vencida"      });      if (pendingInstallments.length > 0 || overdueInstallmentsApi.length > 0) {        throw new Error(          `No se puede eliminar. Hay ${pendingInstallments.length + overdueInstallmentsApi.length} cuotas pendientes.`        );      }      const allInstallments = await installmentsApi.getAll({ creditSaleId });      for (const inst of allInstallments) {        await installmentsApi.delete(inst.id!);      }      await salesApi.delete(creditSaleId);      const dailyCashes = await dailyCashApi.getAll();      for (const dailyCash of dailyCashes) {        const updatedMovements = dailyCash.movements.filter(          (movement: DailyCashMovement) => movement.originalSaleId !== creditSaleId        );        if (updatedMovements.length !== dailyCash.movements.length) {          await dailyCashApi.update(dailyCash.id!, {            movements: updatedMovements,          });        }      }      return {        success: true,        message: "Crédito eliminado correctamente",      };    } catch (error) {      console.error("Error al eliminar el crédito:", error);      throw error;    }  };  const generateCreditReport = useCallback(    async (startDate: string, endDate: string) => {      try {        const allSales = await salesApi.getAll();        const creditSalesData = allSales.filter(          (sale: Sale) => sale.creditType === "credito_cuotas"        ) as CreditSale[];        const creditSaleIds = creditSalesData.map((sale) => sale.id);        let allInstallments: Installment[] = [];        if (creditSaleIds.length > 0) {          for (const id of creditSaleIds) {            const saleInsts = await installmentsApi.getAll({ creditSaleId: id });            allInstallments.push(...saleInsts);          }          allInstallments = allInstallments.filter((installment: Installment) => {            const dueDate = new Date(installment.dueDate);            return (              dueDate >= new Date(startDate) && dueDate <= new Date(endDate)            );          });        }        const report = {          period: { startDate, endDate },          totalCreditSales: creditSalesData.length,          totalAmount: creditSalesData.reduce(            (sum, sale) => sum + sale.total,            0          ),          installmentsByStatus: {            pendiente: allInstallments.filter((i: Installment) => i.status === "pendiente")              .length,            pagada: allInstallments.filter((i: Installment) => i.status === "pagada").length,            vencida: allInstallments.filter((i: Installment) => i.status === "vencida")              .length,          },          totalInterest: allInstallments.reduce(            (sum: number, i: Installment) => sum + (i.interestAmount || 0),            0          ),          totalPenalties: allInstallments.reduce(            (sum: number, i: Installment) => sum + (i.penaltyAmount || 0),            0          ),          overdueInstallments: allInstallments.filter(            (i: Installment) => i.status === "vencida"          ),        };        return report;      } catch (error) {        console.error("Error generating credit report:", error);        throw error;      }    },    []  );  return {    installments,    loading,    overdueInstallments,    calculateInstallments,    checkOverdueInstallments,    fetchInstallments,    payInstallment,    payAllInstallments,    generateCreditReport,    setInstallments,    getCreditSalesInInstallments,    deleteCreditSale,  };};